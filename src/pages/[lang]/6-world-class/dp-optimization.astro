---
import Layout from '../../../layouts/Layout.astro';
import CodeExample from '../../../components/CodeExample.tsx';
import { ui } from '../../../i18n/ui';

export function getStaticPaths() {
  return [
    { params: { lang: 'en' } },
    { params: { lang: 'zh' } }
  ];
}

const { lang } = Astro.params;
const t = ui[lang as keyof typeof ui];
---

<Layout title={lang === 'zh' ? "å•è°ƒDPä¼˜åŒ– - ä¸–ç•Œçº§ç®—æ³•" : "Monotonic DP Optimization - World Class Algorithms"}>
  <div class="container">
    <nav class="breadcrumb">
      <a href={`/${lang}`}>{t['nav.home']}</a> &gt; 
      <a href={`/${lang}/6-world-class`}>{lang === 'zh' ? 'ä¸–ç•Œçº§ç®—æ³•' : 'World Class'}</a> &gt; 
      <span>{lang === 'zh' ? 'å•è°ƒDPä¼˜åŒ–' : 'DP Optimization'}</span>
    </nav>

    <div class="header-section">
      <h1 class="main-title">
        {lang === 'zh' ? 'å•è°ƒDPä¼˜åŒ–' : 'Monotonic DP Optimization'}
      </h1>
      <p class="subtitle">
        {lang === 'zh' 
          ? 'æŒæ¡å‡¸åŒ…æŠ€å·§ã€åˆ†æ²»ä¼˜åŒ–ç­‰é«˜çº§DPåŠ é€Ÿæ–¹æ³•'
          : 'Master convex hull trick, divide-and-conquer optimization, and other advanced DP acceleration methods'
        }
      </p>
    </div>

    <div class="overview-section">
      <h2>{lang === 'zh' ? 'æ¦‚è¿°' : 'Overview'}</h2>
      <p>
        {lang === 'zh' 
          ? 'DPä¼˜åŒ–æŠ€æœ¯æ˜¯è§£å†³å¤§è§„æ¨¡åŠ¨æ€è§„åˆ’é—®é¢˜çš„å…³é”®ã€‚æœ¬ç« èŠ‚æ·±å…¥æ¢è®¨å‡¸åŒ…æŠ€å·§ã€åˆ†æ²»ä¼˜åŒ–ã€å››è¾¹å½¢ä¸ç­‰å¼ç­‰é«˜çº§ä¼˜åŒ–æ–¹æ³•ï¼Œå°†DPå¤æ‚åº¦ä»O(nÂ²)é™ä½åˆ°O(n log n)æˆ–O(n)ã€‚'
          : 'DP optimization techniques are key to solving large-scale dynamic programming problems. This chapter explores convex hull trick, divide-and-conquer optimization, quadrangle inequality, and other advanced methods to reduce DP complexity from O(nÂ²) to O(n log n) or O(n).'
        }
      </p>
    </div>

    <div class="content-section">
      <h2>{lang === 'zh' ? 'æ ¸å¿ƒå†…å®¹' : 'Core Content'}</h2>

      <div class="topic-section">
        <h3>{lang === 'zh' ? '1. å‡¸åŒ…æŠ€å·§ä¼˜åŒ–' : '1. Convex Hull Trick Optimization'}</h3>
        
        <CodeExample
          client:load
          code={`${lang === 'zh' ? '// å‡¸åŒ…æŠ€å·§ä¼˜åŒ–DP' : '// Convex Hull Trick DP optimization'}
#include <iostream>
#include <vector>
#include <deque>
using namespace std;

struct Line {
    long long k, b;
    int id;
    
    Line(long long _k, long long _b, int _id) : k(_k), b(_b), id(_id) {}
    
    long long eval(long long x) {
        return k * x + b;
    }
};

class ConvexHullTrick {
private:
    deque<Line> lines;
    
    ${lang === 'zh' ? '// æ£€æŸ¥æ˜¯å¦éœ€è¦åˆ é™¤ä¸­é—´ç›´çº¿' : '// Check if middle line should be removed'}
    bool bad(Line l1, Line l2, Line l3) {
        ${lang === 'zh' ? '// äº¤ç‚¹æ¯”è¾ƒï¼š(b2-b1)/(k1-k2) >= (b3-b2)/(k2-k3)' : '// Intersection comparison: (b2-b1)/(k1-k2) >= (b3-b2)/(k2-k3)'}
        return (l2.b - l1.b) * (l2.k - l3.k) >= (l3.b - l2.b) * (l1.k - l2.k);
    }
    
public:
    ${lang === 'zh' ? '// æ·»åŠ ç›´çº¿ï¼ˆæ–œç‡é€’å‡ï¼‰' : '// Add line (decreasing slope)'}
    void addLine(long long k, long long b, int id) {
        Line newLine(k, b, id);
        
        ${lang === 'zh' ? '// ç»´æŠ¤ä¸‹å‡¸åŒ…' : '// Maintain lower convex hull'}
        while (lines.size() >= 2 && bad(lines[lines.size()-2], lines[lines.size()-1], newLine)) {
            lines.pop_back();
        }
        lines.push_back(newLine);
    }
    
    ${lang === 'zh' ? '// æŸ¥è¯¢æœ€å°å€¼ï¼ˆxå•è°ƒé€’å¢ï¼‰' : '// Query minimum (x monotonically increasing)'}
    pair<long long, int> queryMin(long long x) {
        ${lang === 'zh' ? '// ç§»é™¤ä¸å†æœ€ä¼˜çš„ç›´çº¿' : '// Remove lines that are no longer optimal'}
        while (lines.size() >= 2 && lines[0].eval(x) >= lines[1].eval(x)) {
            lines.pop_front();
        }
        
        return {lines[0].eval(x), lines[0].id};
    }
    
    void clear() {
        lines.clear();
    }
};

${lang === 'zh' ? '// åº”ç”¨ï¼šæœ€å°è´¹ç”¨è´­ä¹°' : '// Application: Minimum cost buying'}
long long minCostBuying(vector<long long>& cost, vector<long long>& amount) {
    int n = cost.size();
    vector<long long> dp(n + 1, LLONG_MAX);
    vector<long long> prefixSum(n + 1, 0);
    
    ${lang === 'zh' ? '// è®¡ç®—å‰ç¼€å’Œ' : '// Calculate prefix sum'}
    for (int i = 0; i < n; i++) {
        prefixSum[i + 1] = prefixSum[i] + amount[i];
    }
    
    dp[0] = 0;
    ConvexHullTrick cht;
    cht.addLine(0, 0, 0);
    
    for (int i = 1; i <= n; i++) {
        auto [minVal, fromIdx] = cht.queryMin(prefixSum[i]);
        dp[i] = minVal + cost[i - 1] * prefixSum[i];
        
        ${lang === 'zh' ? '// æ·»åŠ æ–°çš„è½¬ç§»ç›´çº¿' : '// Add new transition line'}
        cht.addLine(-prefixSum[i], dp[i], i);
    }
    
    return dp[n];
}

${lang === 'zh' ? '// åº”ç”¨ï¼šæœ€ä¼˜å·¥å‚é€‰å€' : '// Application: Optimal factory placement'}
long long optimalFactoryPlacement(vector<long long>& positions, vector<long long>& demands) {
    int n = positions.size();
    vector<long long> dp(n, LLONG_MAX);
    
    ConvexHullTrick cht;
    
    for (int i = 0; i < n; i++) {
        if (i == 0) {
            dp[i] = 0;
        } else {
            auto [minVal, fromIdx] = cht.queryMin(positions[i]);
            dp[i] = minVal;
        }
        
        ${lang === 'zh' ? '// æ·»åŠ ä»å½“å‰ä½ç½®çš„è½¬ç§»' : '// Add transition from current position'}
        long long slope = -demands[i];
        long long intercept = dp[i] + demands[i] * positions[i];
        cht.addLine(slope, intercept, i);
    }
    
    return dp[n - 1];
}

int main() {
    ${lang === 'zh' ? '// æµ‹è¯•æœ€å°è´¹ç”¨è´­ä¹°' : '// Test minimum cost buying'}
    vector<long long> cost = {2, 3, 1, 4};
    vector<long long> amount = {1, 2, 3, 1};
    
    cout << "${lang === 'zh' ? 'æœ€å°è´­ä¹°è´¹ç”¨ï¼š' : 'Minimum buying cost:'} " 
         << minCostBuying(cost, amount) << endl;
    
    ${lang === 'zh' ? '// æµ‹è¯•å·¥å‚é€‰å€' : '// Test factory placement'}
    vector<long long> positions = {1, 3, 6, 8};
    vector<long long> demands = {2, 1, 3, 2};
    
    cout << "${lang === 'zh' ? 'æœ€ä¼˜å·¥å‚é€‰å€è´¹ç”¨ï¼š' : 'Optimal factory placement cost:'} " 
         << optimalFactoryPlacement(positions, demands) << endl;
    
    return 0;
}`}
          language="cpp"
        />
      </div>

      <div class="topic-section">
        <h3>{lang === 'zh' ? '2. åˆ†æ²»ä¼˜åŒ–' : '2. Divide and Conquer Optimization'}</h3>
        
        <CodeExample
          client:load
          code={`${lang === 'zh' ? '// åˆ†æ²»ä¼˜åŒ–DP' : '// Divide and conquer DP optimization'}
#include <iostream>
#include <vector>
#include <climits>
using namespace std;

class DivideConquerDP {
private:
    vector<vector<long long>> cost;
    vector<long long> dp, newDp;
    int n;
    
    ${lang === 'zh' ? '// è®¡ç®—è½¬ç§»è´¹ç”¨' : '// Calculate transition cost'}
    long long getCost(int i, int j) {
        if (i > j) return LLONG_MAX;
        return cost[i][j];
    }
    
    ${lang === 'zh' ? '// åˆ†æ²»è®¡ç®—DPå€¼' : '// Divide and conquer DP calculation'}
    void solve(int l, int r, int optL, int optR) {
        if (l > r) return;
        
        int mid = (l + r) / 2;
        int optMid = optL;
        long long bestCost = LLONG_MAX;
        
        ${lang === 'zh' ? '// å¯»æ‰¾æœ€ä¼˜è½¬ç§»ç‚¹' : '// Find optimal transition point'}
        for (int k = optL; k <= min(mid - 1, optR); k++) {
            long long currentCost = dp[k] + getCost(k + 1, mid);
            if (currentCost < bestCost) {
                bestCost = currentCost;
                optMid = k;
            }
        }
        
        newDp[mid] = bestCost;
        
        ${lang === 'zh' ? '// é€’å½’å¤„ç†å·¦å³ä¸¤éƒ¨åˆ†' : '// Recursively process left and right parts'}
        solve(l, mid - 1, optL, optMid);
        solve(mid + 1, r, optMid, optR);
    }
    
public:
    ${lang === 'zh' ? '// åˆå§‹åŒ–' : '// Initialize'}
    DivideConquerDP(vector<vector<long long>>& costs) {
        cost = costs;
        n = cost.size();
        dp.resize(n);
        newDp.resize(n);
    }
    
    ${lang === 'zh' ? '// è®¡ç®—æœ€ä¼˜è§£' : '// Calculate optimal solution'}
    long long solve() {
        ${lang === 'zh' ? '// åˆå§‹çŠ¶æ€' : '// Initial state'}
        for (int i = 0; i < n; i++) {
            dp[i] = getCost(0, i);
        }
        
        ${lang === 'zh' ? '// é€å±‚è®¡ç®—' : '// Layer by layer calculation'}
        for (int layer = 1; layer < n; layer++) {
            fill(newDp.begin(), newDp.end(), LLONG_MAX);
            solve(0, n - 1, 0, n - 1);
            dp = newDp;
        }
        
        return dp[n - 1];
    }
};

${lang === 'zh' ? '// åº”ç”¨ï¼šæœ€ä¼˜äºŒåˆ†å›¾åŒ¹é…' : '// Application: Optimal bipartite matching'}
long long optimalMatching(vector<vector<long long>>& weights) {
    int n = weights.size();
    vector<vector<long long>> dp(n, vector<long long>(n, LLONG_MAX));
    
    ${lang === 'zh' ? '// é¢„å¤„ç†åŒºé—´è´¹ç”¨' : '// Preprocess interval costs'}
    for (int i = 0; i < n; i++) {
        for (int j = i; j < n; j++) {
            long long sum = 0;
            for (int k = i; k <= j; k++) {
                sum += weights[k][k]; ${lang === 'zh' ? '// ç®€åŒ–çš„è´¹ç”¨è®¡ç®—' : '// Simplified cost calculation'}
            }
            dp[i][j] = sum;
        }
    }
    
    DivideConquerDP dcDP(dp);
    return dcDP.solve();
}

${lang === 'zh' ? '// åº”ç”¨ï¼šçŸ©é˜µé“¾ä¹˜æ³•ä¼˜åŒ–' : '// Application: Optimized matrix chain multiplication'}
class OptimizedMatrixChain {
private:
    vector<int> dims;
    vector<vector<long long>> cost;
    int n;
    
    void precomputeCosts() {
        cost.assign(n, vector<long long>(n, 0));
        
        for (int len = 2; len <= n; len++) {
            for (int i = 0; i <= n - len; i++) {
                int j = i + len - 1;
                cost[i][j] = LLONG_MAX;
                
                for (int k = i; k < j; k++) {
                    long long c = cost[i][k] + cost[k + 1][j] + 
                                 (long long)dims[i] * dims[k + 1] * dims[j + 1];
                    cost[i][j] = min(cost[i][j], c);
                }
            }
        }
    }
    
public:
    OptimizedMatrixChain(vector<int>& dimensions) {
        dims = dimensions;
        n = dims.size() - 1;
        precomputeCosts();
    }
    
    long long solve() {
        DivideConquerDP dcDP(cost);
        return dcDP.solve();
    }
};

int main() {
    ${lang === 'zh' ? '// æµ‹è¯•æœ€ä¼˜åŒ¹é…' : '// Test optimal matching'}
    vector<vector<long long>> weights = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };
    
    cout << "${lang === 'zh' ? 'æœ€ä¼˜åŒ¹é…è´¹ç”¨ï¼š' : 'Optimal matching cost:'} " 
         << optimalMatching(weights) << endl;
    
    ${lang === 'zh' ? '// æµ‹è¯•çŸ©é˜µé“¾ä¹˜æ³•' : '// Test matrix chain multiplication'}
    vector<int> dimensions = {40, 20, 30, 10, 30};
    OptimizedMatrixChain omc(dimensions);
    
    cout << "${lang === 'zh' ? 'ä¼˜åŒ–åçŸ©é˜µé“¾ä¹˜æ³•è´¹ç”¨ï¼š' : 'Optimized matrix chain cost:'} " 
         << omc.solve() << endl;
    
    return 0;
}`}
          language="cpp"
        />
      </div>
    </div>

    <div class="tips-section">
      <h2>{lang === 'zh' ? 'è§£é¢˜æŠ€å·§' : 'Problem-Solving Tips'}</h2>
      <div class="tips-grid">
        <div class="tip-card">
          <h3>ğŸ¯ {lang === 'zh' ? 'ä¼˜åŒ–è¯†åˆ«' : 'Optimization Recognition'}</h3>
          <p>
            {lang === 'zh' 
              ? 'è¯†åˆ«DPä¼˜åŒ–çš„é€‚ç”¨æ¡ä»¶ï¼šå‡¸åŒ…æŠ€å·§éœ€è¦å•è°ƒæ€§ï¼Œåˆ†æ²»ä¼˜åŒ–éœ€è¦å››è¾¹å½¢ä¸ç­‰å¼ã€‚'
              : 'Recognize conditions for DP optimization: convex hull trick needs monotonicity, divide-and-conquer needs quadrangle inequality.'
            }
          </p>
        </div>
        
        <div class="tip-card">
          <h3>âš¡ {lang === 'zh' ? 'å¤æ‚åº¦åˆ†æ' : 'Complexity Analysis'}</h3>
          <p>
            {lang === 'zh' 
              ? 'æ­£ç¡®åˆ†æä¼˜åŒ–åçš„å¤æ‚åº¦ï¼šå‡¸åŒ…æŠ€å·§O(n)ï¼Œåˆ†æ²»ä¼˜åŒ–O(n log n)ï¼Œé€‰æ‹©åˆé€‚çš„ä¼˜åŒ–æ–¹æ³•ã€‚'
              : 'Correctly analyze optimized complexity: convex hull trick O(n), divide-and-conquer O(n log n), choose appropriate optimization methods.'
            }
          </p>
        </div>
        
        <div class="tip-card">
          <h3>ğŸ”§ {lang === 'zh' ? 'å®ç°ç»†èŠ‚' : 'Implementation Details'}</h3>
          <p>
            {lang === 'zh' 
              ? 'æ³¨æ„æ•°å€¼ç²¾åº¦å’Œè¾¹ç•Œæ¡ä»¶ï¼Œæ­£ç¡®ç»´æŠ¤æ•°æ®ç»“æ„çš„å•è°ƒæ€§è´¨ã€‚'
              : 'Pay attention to numerical precision and boundary conditions, correctly maintain monotonic properties of data structures.'
            }
          </p>
        </div>
        
        <div class="tip-card">
          <h3>ğŸ§® {lang === 'zh' ? 'åº”ç”¨åœºæ™¯' : 'Application Scenarios'}</h3>
          <p>
            {lang === 'zh' 
              ? 'é€‚ç”¨äºå¤§è§„æ¨¡DPé—®é¢˜ï¼šå·¥å‚é€‰å€ã€èµ„æºåˆ†é…ã€è·¯å¾„ä¼˜åŒ–ç­‰ç»å…¸é—®é¢˜ã€‚'
              : 'Suitable for large-scale DP problems: factory placement, resource allocation, path optimization, and other classic problems.'
            }
          </p>
        </div>
      </div>
    </div>

    <div class="navigation">
      <a href={`/${lang}/6-world-class/balanced-tree`} class="nav-button prev">
        â† {lang === 'zh' ? 'å¹³è¡¡æ ‘' : 'Balanced Trees'}
      </a>
      <a href={`/${lang}/6-world-class`} class="nav-button index">
        ğŸ“š {lang === 'zh' ? 'ç« èŠ‚ç›®å½•' : 'Chapter Index'}
      </a>
      <a href={`/${lang}/6-world-class/heavy-light`} class="nav-button next">
        {lang === 'zh' ? 'é‡é“¾å‰–åˆ†' : 'Heavy-Light Decomposition'} â†’
      </a>
    </div>
  </div>
</Layout>

<style>
  .container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 0 1rem;
  }

  .breadcrumb {
    font-size: 0.9rem;
    color: #6b7280;
    margin-bottom: 2rem;
    padding: 1rem 0;
    border-bottom: 1px solid #e5e7eb;
  }

  .breadcrumb a {
    color: #4f46e5;
    text-decoration: none;
    transition: color 0.2s;
  }

  .breadcrumb a:hover {
    color: #3730a3;
    text-decoration: underline;
  }

  .header-section {
    text-align: center;
    margin-bottom: 3rem;
  }

  .main-title {
    font-size: 3.5rem;
    font-weight: 900;
    margin-bottom: 1rem;
    background: linear-gradient(135deg, #dc2626 0%, #ea580c 25%, #d97706 50%, #ca8a04 75%, #65a30d 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    line-height: 1.1;
  }

  .subtitle {
    font-size: 1.25rem;
    color: #6b7280;
    max-width: 600px;
    margin: 0 auto;
    line-height: 1.6;
  }

  .overview-section {
    background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
    border: 1px solid #f59e0b;
    border-radius: 16px;
    padding: 2.5rem;
    margin: 2rem 0 3rem 0;
    box-shadow: 0 4px 6px -1px rgba(245, 158, 11, 0.1);
  }

  .overview-section h2 {
    color: #92400e;
    font-size: 1.5rem;
    font-weight: 700;
    margin-bottom: 1rem;
  }

  .overview-section p {
    margin: 0;
    font-size: 1.1rem;
    line-height: 1.8;
    color: #78350f;
  }

  .content-section {
    margin: 4rem 0;
  }

  .content-section > h2 {
    font-size: 2.5rem;
    font-weight: 700;
    margin-bottom: 3rem;
    color: #1e293b;
    text-align: center;
    position: relative;
  }

  .content-section > h2::after {
    content: '';
    position: absolute;
    bottom: -0.5rem;
    left: 50%;
    transform: translateX(-50%);
    width: 80px;
    height: 4px;
    background: linear-gradient(90deg, #dc2626, #ea580c, #d97706);
    border-radius: 2px;
  }

  .topic-section {
    margin: 3rem 0;
    padding: 2rem;
    background: #f8fafc;
    border-radius: 12px;
    border-left: 4px solid #dc2626;
  }

  .topic-section h3 {
    color: #dc2626;
    font-size: 1.75rem;
    font-weight: 700;
    margin-bottom: 1rem;
  }

  .topic-section p {
    color: #4b5563;
    line-height: 1.7;
    margin-bottom: 1.5rem;
  }

  .tips-section {
    margin: 4rem 0;
    padding: 2rem 0;
    border-top: 2px solid #e5e7eb;
  }

  .tips-section h2 {
    font-size: 2.25rem;
    font-weight: 700;
    margin-bottom: 2rem;
    color: #1e293b;
    text-align: center;
  }

  .tips-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 1.5rem;
    margin-top: 2rem;
  }

  .tip-card {
    background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
    border: 1px solid #0ea5e9;
    border-radius: 12px;
    padding: 1.5rem;
    transition: transform 0.2s ease;
  }

  .tip-card:hover {
    transform: translateY(-2px);
  }

  .tip-card h3 {
    color: #0c4a6e;
    font-size: 1.1rem;
    font-weight: 700;
    margin-bottom: 0.75rem;
  }

  .tip-card p {
    color: #075985;
    line-height: 1.6;
    margin: 0;
    font-size: 0.95rem;
  }

  .navigation {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin: 4rem 0 2rem 0;
    padding: 2rem 0;
    border-top: 2px solid #e5e7eb;
    gap: 1rem;
  }

  .nav-button {
    display: inline-flex;
    align-items: center;
    padding: 0.875rem 1.75rem;
    background: linear-gradient(135deg, #dc2626, #b91c1c);
    color: white;
    text-decoration: none;
    border-radius: 10px;
    font-weight: 600;
    font-size: 0.95rem;
    transition: all 0.3s ease;
    box-shadow: 0 4px 14px 0 rgba(220, 38, 38, 0.39);
  }

  .nav-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px 0 rgba(220, 38, 38, 0.5);
  }

  .nav-button.index {
    background: linear-gradient(135deg, #059669, #0d9488);
    box-shadow: 0 4px 14px 0 rgba(5, 150, 105, 0.39);
  }

  .nav-button.index:hover {
    box-shadow: 0 8px 25px 0 rgba(5, 150, 105, 0.5);
  }

  @media (max-width: 768px) {
    .container {
      padding: 0 0.5rem;
    }

    .main-title {
      font-size: 2.5rem;
    }

    .subtitle {
      font-size: 1.1rem;
    }

    .overview-section {
      padding: 1.5rem;
      margin: 1.5rem 0 2rem 0;
    }

    .topic-section {
      padding: 1.5rem;
    }

    .tips-grid {
      grid-template-columns: 1fr;
    }

    .navigation {
      flex-direction: column;
      gap: 1rem;
    }

    .nav-button {
      width: 100%;
      justify-content: center;
    }
  }
</style> 