---
import Layout from '../../../layouts/Layout.astro';
import CodeExample from '../../../components/CodeExample.tsx';
import { ui } from '../../../i18n/ui';

export function getStaticPaths() {
  return [
    { params: { lang: 'en' } },
    { params: { lang: 'zh' } }
  ];
}

const { lang } = Astro.params;
const t = ui[lang as keyof typeof ui];
---

<Layout title={lang === 'zh' ? "é«˜çº§æ ‘é—®é¢˜ - ä¸–ç•Œçº§ç®—æ³•" : "Advanced Tree Problems - World Class Algorithms"}>
  <div class="container">
    <nav class="breadcrumb">
      <a href={`/${lang}`}>{t['nav.home']}</a> &gt; 
      <a href={`/${lang}/6-world-class`}>{lang === 'zh' ? 'ä¸–ç•Œçº§ç®—æ³•' : 'World Class'}</a> &gt; 
      <span>{lang === 'zh' ? 'é«˜çº§æ ‘é—®é¢˜' : 'Advanced Tree Problems'}</span>
    </nav>

    <div class="header-section">
      <h1 class="main-title">
        {lang === 'zh' ? 'é«˜çº§æ ‘é—®é¢˜' : 'Advanced Tree Problems'}
      </h1>
      <p class="subtitle">
        {lang === 'zh' 
          ? 'æŒæ¡DFSåºã€æ ‘ä¸çº¿æ®µæ ‘ç»“åˆç­‰é«˜çº§æ ‘ç®—æ³•æŠ€å·§'
          : 'Master DFS ordering, tree + segment tree combinations, and advanced tree algorithms'
        }
      </p>
    </div>

    <div class="overview-section">
      <h2>{lang === 'zh' ? 'æ¦‚è¿°' : 'Overview'}</h2>
      <p>
        {lang === 'zh' 
          ? 'é«˜çº§æ ‘é—®é¢˜æ˜¯ç®—æ³•ç«èµ›ä¸­çš„æ ¸å¿ƒå†…å®¹ï¼Œæ¶‰åŠDFSåºåˆ—åŒ–ã€æ ‘ä¸æ•°æ®ç»“æ„ç»“åˆã€å¤æ‚æ ‘ç®—æ³•ç­‰æŠ€æœ¯ã€‚æœ¬ç« èŠ‚æ·±å…¥æ¢è®¨è¿™äº›é«˜çº§æŠ€å·§ï¼Œä¸ºè§£å†³ä¸–ç•Œçº§ç«èµ›ä¸­çš„å¤æ‚æ ‘é—®é¢˜æä¾›å¼ºå¤§å·¥å…·ã€‚'
          : 'Advanced tree problems are core content in competitive programming, involving DFS serialization, tree-data structure combinations, and complex tree algorithms. This chapter explores these advanced techniques for solving complex tree problems in world-class competitions.'
        }
      </p>
    </div>

    <div class="content-section">
      <h2>{lang === 'zh' ? 'æ ¸å¿ƒå†…å®¹' : 'Core Content'}</h2>

      <div class="topic-section">
        <h3>{lang === 'zh' ? '1. DFSåºä¸æ ‘çš„çº¿æ€§åŒ–' : '1. DFS Ordering and Tree Linearization'}</h3>
        <p>
          {lang === 'zh' 
            ? 'DFSåºå°†æ ‘ç»“æ„è½¬æ¢ä¸ºçº¿æ€§åºåˆ—ï¼Œä½¿å¾—æ ‘ä¸Šçš„å­æ ‘æŸ¥è¯¢è½¬åŒ–ä¸ºåŒºé—´æŸ¥è¯¢ã€‚'
            : 'DFS ordering converts tree structure to linear sequence, transforming subtree queries to range queries.'
          }
        </p>

        <CodeExample
          client:load
          code={`${lang === 'zh' ? '// DFSåºä¸æ ‘çš„çº¿æ€§åŒ–' : '// DFS ordering and tree linearization'}
#include <iostream>
#include <vector>
using namespace std;

class TreeDFS {
private:
    vector<vector<int>> adj;
    vector<int> dfs_order, start_time, end_time;
    vector<int> depth, parent;
    int timer;
    
    void dfs(int u, int p, int d) {
        start_time[u] = timer;
        dfs_order[timer++] = u;
        depth[u] = d;
        parent[u] = p;
        
        for (int v : adj[u]) {
            if (v != p) {
                dfs(v, u, d + 1);
            }
        }
        
        end_time[u] = timer - 1;
    }
    
public:
    void build(vector<vector<int>>& edges, int root = 0) {
        int n = edges.size() + 1;
        adj.resize(n);
        dfs_order.resize(n);
        start_time.resize(n);
        end_time.resize(n);
        depth.resize(n);
        parent.resize(n);
        timer = 0;
        
        for (auto& edge : edges) {
            adj[edge[0]].push_back(edge[1]);
            adj[edge[1]].push_back(edge[0]);
        }
        
        dfs(root, -1, 0);
    }
    
    ${lang === 'zh' ? '// æ£€æŸ¥uæ˜¯å¦æ˜¯vçš„ç¥–å…ˆ' : '// Check if u is ancestor of v'}
    bool isAncestor(int u, int v) {
        return start_time[u] <= start_time[v] && end_time[v] <= end_time[u];
    }
    
    ${lang === 'zh' ? '// è·å–å­æ ‘çš„DFSåºåŒºé—´' : '// Get DFS range of subtree'}
    pair<int, int> getSubtreeRange(int u) {
        return {start_time[u], end_time[u]};
    }
    
    void printDFSOrder() {
        cout << "${lang === 'zh' ? 'DFSåºï¼š' : 'DFS order:'} ";
        for (int i = 0; i < dfs_order.size(); i++) {
            cout << dfs_order[i] << " ";
        }
        cout << endl;
    }
};

int main() {
    vector<vector<int>> edges = {{0,1}, {0,2}, {1,3}, {1,4}, {2,5}};
    TreeDFS treeDFS;
    treeDFS.build(edges);
    treeDFS.printDFSOrder();
    
    cout << "${lang === 'zh' ? 'èŠ‚ç‚¹1çš„å­æ ‘åŒºé—´ï¼š[' : 'Node 1 subtree range: ['}" 
         << treeDFS.getSubtreeRange(1).first << ", " 
         << treeDFS.getSubtreeRange(1).second << "]" << endl;
    
    return 0;
}`}
          language="cpp"
        />
      </div>

      <div class="topic-section">
        <h3>{lang === 'zh' ? '2. æ ‘ä¸çº¿æ®µæ ‘ç»“åˆ' : '2. Tree + Segment Tree'}</h3>
        <p>
          {lang === 'zh' 
            ? 'é€šè¿‡DFSåºå°†æ ‘é—®é¢˜è½¬åŒ–ä¸ºçº¿æ®µæ ‘é—®é¢˜ï¼Œæ”¯æŒå­æ ‘æ›´æ–°å’ŒæŸ¥è¯¢æ“ä½œã€‚'
            : 'Transform tree problems to segment tree problems using DFS ordering, supporting subtree updates and queries.'
          }
        </p>

        <CodeExample
          client:load
          code={`${lang === 'zh' ? '// æ ‘ä¸çº¿æ®µæ ‘ç»“åˆè§£å†³å­æ ‘é—®é¢˜' : '// Tree + Segment Tree for subtree problems'}
#include <iostream>
#include <vector>
using namespace std;

class TreeSegmentTree {
private:
    vector<vector<int>> adj;
    vector<int> start_time, end_time, values;
    vector<long long> tree, lazy;
    int n, timer;
    
    void dfs(int u, int p) {
        start_time[u] = timer++;
        for (int v : adj[u]) {
            if (v != p) dfs(v, u);
        }
        end_time[u] = timer - 1;
    }
    
    void build(int node, int start, int end) {
        if (start == end) {
            tree[node] = values[start];
        } else {
            int mid = (start + end) / 2;
            build(2*node, start, mid);
            build(2*node+1, mid+1, end);
            tree[node] = tree[2*node] + tree[2*node+1];
        }
    }
    
    void updateLazy(int node, int start, int end) {
        if (lazy[node] != 0) {
            tree[node] += lazy[node] * (end - start + 1);
            if (start != end) {
                lazy[2*node] += lazy[node];
                lazy[2*node+1] += lazy[node];
            }
            lazy[node] = 0;
        }
    }
    
    void updateRange(int node, int start, int end, int l, int r, long long val) {
        updateLazy(node, start, end);
        if (start > r || end < l) return;
        
        if (start >= l && end <= r) {
            lazy[node] += val;
            updateLazy(node, start, end);
            return;
        }
        
        int mid = (start + end) / 2;
        updateRange(2*node, start, mid, l, r, val);
        updateRange(2*node+1, mid+1, end, l, r, val);
        
        updateLazy(2*node, start, mid);
        updateLazy(2*node+1, mid+1, end);
        tree[node] = tree[2*node] + tree[2*node+1];
    }
    
    long long queryRange(int node, int start, int end, int l, int r) {
        if (start > r || end < l) return 0;
        updateLazy(node, start, end);
        
        if (start >= l && end <= r) return tree[node];
        
        int mid = (start + end) / 2;
        return queryRange(2*node, start, mid, l, r) + 
               queryRange(2*node+1, mid+1, end, l, r);
    }
    
public:
    void initialize(vector<vector<int>>& edges, vector<int>& nodeValues, int root = 0) {
        n = edges.size() + 1;
        adj.resize(n);
        start_time.resize(n);
        end_time.resize(n);
        values.resize(n);
        tree.resize(4 * n);
        lazy.resize(4 * n);
        timer = 0;
        
        for (auto& edge : edges) {
            adj[edge[0]].push_back(edge[1]);
            adj[edge[1]].push_back(edge[0]);
        }
        
        dfs(root, -1);
        
        ${lang === 'zh' ? '// æŒ‰DFSåºé‡æ’å€¼' : '// Rearrange values by DFS order'}
        for (int i = 0; i < n; i++) {
            values[start_time[i]] = nodeValues[i];
        }
        
        build(1, 0, n - 1);
    }
    
    ${lang === 'zh' ? '// å­æ ‘æ›´æ–°' : '// Subtree update'}
    void updateSubtree(int u, long long val) {
        updateRange(1, 0, n - 1, start_time[u], end_time[u], val);
    }
    
    ${lang === 'zh' ? '// å­æ ‘æŸ¥è¯¢' : '// Subtree query'}
    long long querySubtree(int u) {
        return queryRange(1, 0, n - 1, start_time[u], end_time[u]);
    }
};

int main() {
    vector<vector<int>> edges = {{0,1}, {0,2}, {1,3}, {1,4}, {2,5}};
    vector<int> values = {1, 2, 3, 4, 5, 6};
    
    TreeSegmentTree tst;
    tst.initialize(edges, values);
    
    cout << "${lang === 'zh' ? 'èŠ‚ç‚¹1å­æ ‘å’Œï¼š' : 'Node 1 subtree sum:'} " << tst.querySubtree(1) << endl;
    
    tst.updateSubtree(1, 10);
    cout << "${lang === 'zh' ? 'æ›´æ–°åèŠ‚ç‚¹1å­æ ‘å’Œï¼š' : 'After update, node 1 subtree sum:'} " << tst.querySubtree(1) << endl;
    
    return 0;
}`}
          language="cpp"
        />
      </div>

      <div class="topic-section">
        <h3>{lang === 'zh' ? '3. é«˜çº§æ ‘ç®—æ³•' : '3. Advanced Tree Algorithms'}</h3>
        
        <CodeExample
          client:load
          code={`${lang === 'zh' ? '// æ ‘é“¾å‰–åˆ†ä¸LCA' : '// Tree chain decomposition and LCA'}
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

class TreeChainDecomposition {
private:
    vector<vector<int>> adj;
    vector<int> parent, depth, heavy, head, pos;
    int timer;
    
    int dfs1(int u) {
        int size = 1, maxSize = 0;
        for (int v : adj[u]) {
            if (v != parent[u]) {
                parent[v] = u;
                depth[v] = depth[u] + 1;
                int childSize = dfs1(v);
                if (childSize > maxSize) {
                    maxSize = childSize;
                    heavy[u] = v;
                }
                size += childSize;
            }
        }
        return size;
    }
    
    void dfs2(int u, int h) {
        head[u] = h;
        pos[u] = timer++;
        
        if (heavy[u] != -1) {
            dfs2(heavy[u], h);
        }
        
        for (int v : adj[u]) {
            if (v != parent[u] && v != heavy[u]) {
                dfs2(v, v);
            }
        }
    }
    
public:
    void build(vector<vector<int>>& edges, int root = 0) {
        int n = edges.size() + 1;
        adj.resize(n);
        parent.resize(n);
        depth.resize(n);
        heavy.assign(n, -1);
        head.resize(n);
        pos.resize(n);
        timer = 0;
        
        for (auto& edge : edges) {
            adj[edge[0]].push_back(edge[1]);
            adj[edge[1]].push_back(edge[0]);
        }
        
        parent[root] = -1;
        depth[root] = 0;
        dfs1(root);
        dfs2(root, root);
    }
    
    int lca(int u, int v) {
        while (head[u] != head[v]) {
            if (depth[head[u]] > depth[head[v]]) {
                u = parent[head[u]];
            } else {
                v = parent[head[v]];
            }
        }
        return depth[u] < depth[v] ? u : v;
    }
    
    int distance(int u, int v) {
        return depth[u] + depth[v] - 2 * depth[lca(u, v)];
    }
};

${lang === 'zh' ? '// æ ‘çš„ç›´å¾„å’Œä¸­å¿ƒ' : '// Tree diameter and center'}
class TreeDiameterCenter {
private:
    vector<vector<int>> adj;
    vector<int> dist;
    
    pair<int, int> bfs(int start) {
        fill(dist.begin(), dist.end(), -1);
        queue<int> q;
        q.push(start);
        dist[start] = 0;
        
        int farthest = start, maxDist = 0;
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            
            for (int v : adj[u]) {
                if (dist[v] == -1) {
                    dist[v] = dist[u] + 1;
                    q.push(v);
                    if (dist[v] > maxDist) {
                        maxDist = dist[v];
                        farthest = v;
                    }
                }
            }
        }
        
        return {farthest, maxDist};
    }
    
public:
    void build(vector<vector<int>>& edges) {
        int n = edges.size() + 1;
        adj.resize(n);
        dist.resize(n);
        
        for (auto& edge : edges) {
            adj[edge[0]].push_back(edge[1]);
            adj[edge[1]].push_back(edge[0]);
        }
    }
    
    pair<int, vector<int>> findDiameter() {
        ${lang === 'zh' ? '// ç¬¬ä¸€æ¬¡BFSæ‰¾åˆ°æœ€è¿œç‚¹' : '// First BFS to find farthest point'}
        auto [u, _] = bfs(0);
        
        ${lang === 'zh' ? '// ç¬¬äºŒæ¬¡BFSæ‰¾åˆ°ç›´å¾„' : '// Second BFS to find diameter'}
        auto [v, diameter] = bfs(u);
        
        ${lang === 'zh' ? '// é‡æ„ç›´å¾„è·¯å¾„' : '// Reconstruct diameter path'}
        vector<int> path;
        int curr = v;
        while (curr != u) {
            path.push_back(curr);
            for (int next : adj[curr]) {
                if (dist[next] == dist[curr] - 1) {
                    curr = next;
                    break;
                }
            }
        }
        path.push_back(u);
        reverse(path.begin(), path.end());
        
        return {diameter, path};
    }
    
    vector<int> findCenter() {
        auto [diameter, path] = findDiameter();
        vector<int> centers;
        
        int n = path.size();
        if (n % 2 == 1) {
            centers.push_back(path[n / 2]);
        } else {
            centers.push_back(path[n / 2 - 1]);
            centers.push_back(path[n / 2]);
        }
        
        return centers;
    }
};

int main() {
    vector<vector<int>> edges = {{0,1}, {1,2}, {2,3}, {1,4}, {4,5}};
    
    ${lang === 'zh' ? '// æµ‹è¯•æ ‘é“¾å‰–åˆ†' : '// Test tree chain decomposition'}
    TreeChainDecomposition tcd;
    tcd.build(edges);
    
    cout << "${lang === 'zh' ? 'èŠ‚ç‚¹3å’Œ5çš„LCAï¼š' : 'LCA of nodes 3 and 5:'} " << tcd.lca(3, 5) << endl;
    cout << "${lang === 'zh' ? 'èŠ‚ç‚¹3å’Œ5çš„è·ç¦»ï¼š' : 'Distance between nodes 3 and 5:'} " << tcd.distance(3, 5) << endl;
    
    ${lang === 'zh' ? '// æµ‹è¯•ç›´å¾„å’Œä¸­å¿ƒ' : '// Test diameter and center'}
    TreeDiameterCenter tdc;
    tdc.build(edges);
    
    auto [diameter, path] = tdc.findDiameter();
    cout << "${lang === 'zh' ? 'æ ‘çš„ç›´å¾„ï¼š' : 'Tree diameter:'} " << diameter << endl;
    
    vector<int> centers = tdc.findCenter();
    cout << "${lang === 'zh' ? 'æ ‘çš„ä¸­å¿ƒï¼š' : 'Tree centers:'} ";
    for (int center : centers) {
        cout << center << " ";
    }
    cout << endl;
    
    return 0;
}`}
          language="cpp"
        />
      </div>
    </div>

    <div class="tips-section">
      <h2>{lang === 'zh' ? 'è§£é¢˜æŠ€å·§' : 'Problem-Solving Tips'}</h2>
      <div class="tips-grid">
        <div class="tip-card">
          <h3>ğŸ¯ {lang === 'zh' ? 'DFSåºåº”ç”¨' : 'DFS Order Applications'}</h3>
          <p>
            {lang === 'zh' 
              ? 'åˆ©ç”¨DFSåºå°†æ ‘é—®é¢˜è½¬åŒ–ä¸ºåºåˆ—é—®é¢˜ï¼Œå­æ ‘æ“ä½œå˜ä¸ºåŒºé—´æ“ä½œï¼Œå¤§å¤§ç®€åŒ–é—®é¢˜å¤æ‚åº¦ã€‚'
              : 'Use DFS ordering to transform tree problems to sequence problems, converting subtree operations to range operations, greatly simplifying complexity.'
            }
          </p>
        </div>
        
        <div class="tip-card">
          <h3>âš¡ {lang === 'zh' ? 'æ•°æ®ç»“æ„ç»“åˆ' : 'Data Structure Integration'}</h3>
          <p>
            {lang === 'zh' 
              ? 'æ ‘ä¸çº¿æ®µæ ‘ã€æ ‘çŠ¶æ•°ç»„ç­‰æ•°æ®ç»“æ„ç»“åˆï¼Œå¯ä»¥é«˜æ•ˆå¤„ç†æ ‘ä¸Šçš„åŒºé—´æŸ¥è¯¢å’Œæ›´æ–°æ“ä½œã€‚'
              : 'Combining trees with segment trees, Fenwick trees, and other data structures enables efficient range queries and updates on trees.'
            }
          </p>
        </div>
        
        <div class="tip-card">
          <h3>ğŸ”„ {lang === 'zh' ? 'æ ‘çš„æ€§è´¨' : 'Tree Properties'}</h3>
          <p>
            {lang === 'zh' 
              ? 'æ·±å…¥ç†è§£æ ‘çš„æ€§è´¨ï¼šç›´å¾„ã€ä¸­å¿ƒã€é‡å¿ƒç­‰ï¼Œè¿™äº›æ€§è´¨åœ¨è§£å†³å¤æ‚æ ‘é—®é¢˜æ—¶éå¸¸æœ‰ç”¨ã€‚'
              : 'Deeply understand tree properties: diameter, center, centroid, etc. These properties are very useful for solving complex tree problems.'
            }
          </p>
        </div>
        
        <div class="tip-card">
          <h3>ğŸ§® {lang === 'zh' ? 'ç®—æ³•ä¼˜åŒ–' : 'Algorithm Optimization'}</h3>
          <p>
            {lang === 'zh' 
              ? 'ä½¿ç”¨é‡é“¾å‰–åˆ†ã€LCAé¢„å¤„ç†ç­‰æŠ€æœ¯ä¼˜åŒ–æ ‘ä¸ŠæŸ¥è¯¢ï¼Œå°†å¤æ‚åº¦ä»O(n)é™ä½åˆ°O(log n)ã€‚'
              : 'Use heavy-light decomposition, LCA preprocessing, and other techniques to optimize tree queries, reducing complexity from O(n) to O(log n).'
            }
          </p>
        </div>
      </div>
    </div>

    <div class="navigation">
      <a href={`/${lang}/6-world-class/advanced-dp`} class="nav-button prev">
        â† {lang === 'zh' ? 'é«˜çº§åŠ¨æ€è§„åˆ’' : 'Advanced DP'}
      </a>
      <a href={`/${lang}/6-world-class`} class="nav-button index">
        ğŸ“š {lang === 'zh' ? 'ç« èŠ‚ç›®å½•' : 'Chapter Index'}
      </a>
      <a href={`/${lang}/6-world-class/segment-tree-advanced`} class="nav-button next">
        {lang === 'zh' ? 'é«˜çº§çº¿æ®µæ ‘' : 'Advanced Segment Trees'} â†’
      </a>
    </div>
  </div>
</Layout>

<style>
  .container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 0 1rem;
  }

  .breadcrumb {
    font-size: 0.9rem;
    color: #6b7280;
    margin-bottom: 2rem;
    padding: 1rem 0;
    border-bottom: 1px solid #e5e7eb;
  }

  .breadcrumb a {
    color: #4f46e5;
    text-decoration: none;
    transition: color 0.2s;
  }

  .breadcrumb a:hover {
    color: #3730a3;
    text-decoration: underline;
  }

  .header-section {
    text-align: center;
    margin-bottom: 3rem;
  }

  .main-title {
    font-size: 3.5rem;
    font-weight: 900;
    margin-bottom: 1rem;
    background: linear-gradient(135deg, #dc2626 0%, #ea580c 25%, #d97706 50%, #ca8a04 75%, #65a30d 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    line-height: 1.1;
  }

  .subtitle {
    font-size: 1.25rem;
    color: #6b7280;
    max-width: 600px;
    margin: 0 auto;
    line-height: 1.6;
  }

  .overview-section {
    background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
    border: 1px solid #f59e0b;
    border-radius: 16px;
    padding: 2.5rem;
    margin: 2rem 0 3rem 0;
    box-shadow: 0 4px 6px -1px rgba(245, 158, 11, 0.1);
  }

  .overview-section h2 {
    color: #92400e;
    font-size: 1.5rem;
    font-weight: 700;
    margin-bottom: 1rem;
  }

  .overview-section p {
    margin: 0;
    font-size: 1.1rem;
    line-height: 1.8;
    color: #78350f;
  }

  .content-section {
    margin: 4rem 0;
  }

  .content-section > h2 {
    font-size: 2.5rem;
    font-weight: 700;
    margin-bottom: 3rem;
    color: #1e293b;
    text-align: center;
    position: relative;
  }

  .content-section > h2::after {
    content: '';
    position: absolute;
    bottom: -0.5rem;
    left: 50%;
    transform: translateX(-50%);
    width: 80px;
    height: 4px;
    background: linear-gradient(90deg, #dc2626, #ea580c, #d97706);
    border-radius: 2px;
  }

  .topic-section {
    margin: 3rem 0;
    padding: 2rem;
    background: #f8fafc;
    border-radius: 12px;
    border-left: 4px solid #dc2626;
  }

  .topic-section h3 {
    color: #dc2626;
    font-size: 1.75rem;
    font-weight: 700;
    margin-bottom: 1rem;
  }

  .topic-section p {
    color: #4b5563;
    line-height: 1.7;
    margin-bottom: 1.5rem;
  }

  .tips-section {
    margin: 4rem 0;
    padding: 2rem 0;
    border-top: 2px solid #e5e7eb;
  }

  .tips-section h2 {
    font-size: 2.25rem;
    font-weight: 700;
    margin-bottom: 2rem;
    color: #1e293b;
    text-align: center;
  }

  .tips-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 1.5rem;
    margin-top: 2rem;
  }

  .tip-card {
    background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
    border: 1px solid #0ea5e9;
    border-radius: 12px;
    padding: 1.5rem;
    transition: transform 0.2s ease;
  }

  .tip-card:hover {
    transform: translateY(-2px);
  }

  .tip-card h3 {
    color: #0c4a6e;
    font-size: 1.1rem;
    font-weight: 700;
    margin-bottom: 0.75rem;
  }

  .tip-card p {
    color: #075985;
    line-height: 1.6;
    margin: 0;
    font-size: 0.95rem;
  }

  .navigation {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin: 4rem 0 2rem 0;
    padding: 2rem 0;
    border-top: 2px solid #e5e7eb;
    gap: 1rem;
  }

  .nav-button {
    display: inline-flex;
    align-items: center;
    padding: 0.875rem 1.75rem;
    background: linear-gradient(135deg, #dc2626, #b91c1c);
    color: white;
    text-decoration: none;
    border-radius: 10px;
    font-weight: 600;
    font-size: 0.95rem;
    transition: all 0.3s ease;
    box-shadow: 0 4px 14px 0 rgba(220, 38, 38, 0.39);
  }

  .nav-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px 0 rgba(220, 38, 38, 0.5);
  }

  .nav-button.index {
    background: linear-gradient(135deg, #059669, #0d9488);
    box-shadow: 0 4px 14px 0 rgba(5, 150, 105, 0.39);
  }

  .nav-button.index:hover {
    box-shadow: 0 8px 25px 0 rgba(5, 150, 105, 0.5);
  }

  @media (max-width: 768px) {
    .container {
      padding: 0 0.5rem;
    }

    .main-title {
      font-size: 2.5rem;
    }

    .subtitle {
      font-size: 1.1rem;
    }

    .overview-section {
      padding: 1.5rem;
      margin: 1.5rem 0 2rem 0;
    }

    .topic-section {
      padding: 1.5rem;
    }

    .tips-grid {
      grid-template-columns: 1fr;
    }

    .navigation {
      flex-direction: column;
      gap: 1rem;
    }

    .nav-button {
      width: 100%;
      justify-content: center;
    }
  }
</style> 