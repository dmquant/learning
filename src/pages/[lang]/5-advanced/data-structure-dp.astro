---
import Layout from '../../../layouts/Layout.astro';
import CodeExample from '../../../components/CodeExample.tsx';
import { ui } from '../../../i18n/ui';

export function getStaticPaths() {
  return [
    { params: { lang: 'en' } },
    { params: { lang: 'zh' } }
  ];
}

const { lang } = Astro.params;
const t = ui[lang as keyof typeof ui];
---

<Layout title={lang === 'zh' ? "æ•°æ®ç»“æ„ä¼˜åŒ–DP - é«˜çº§ç®—æ³•" : "Data Structure Optimized DP - Advanced Algorithms"}>
  <div class="container">
    <!-- Breadcrumb -->
    <nav class="text-sm breadcrumbs mb-6">
      <ul class="flex space-x-2 text-gray-600">
        <li><a href={`/${lang}`} class="hover:text-blue-600">{t['nav.home']}</a></li>
        <li><span class="mx-2">/</span></li>
        <li><a href={`/${lang}/5-advanced`} class="hover:text-blue-600">{lang === 'zh' ? 'é«˜çº§ç®—æ³•' : 'Advanced Algorithms'}</a></li>
        <li><span class="mx-2">/</span></li>
        <li class="text-gray-900">{lang === 'zh' ? 'æ•°æ®ç»“æ„ä¼˜åŒ–DP' : 'Data Structure Optimized DP'}</li>
      </ul>
    </nav>

    <h1 class="main-title">
      {lang === 'zh' ? 'æ•°æ®ç»“æ„ä¼˜åŒ–DP' : 'Data Structure Optimized DP'}
    </h1>

    <!-- Overview -->
    <div class="overview-section">
      <h2>{lang === 'zh' ? 'æ¦‚è¿°' : 'Overview'}</h2>
      <p>
        {lang === 'zh' 
          ? 'æ•°æ®ç»“æ„ä¼˜åŒ–åŠ¨æ€è§„åˆ’æ˜¯ä¸€ç§é€šè¿‡é«˜çº§æ•°æ®ç»“æ„å°†ä½æ•ˆDPè§£å†³æ–¹æ¡ˆè½¬æ¢ä¸ºæœ€ä¼˜è§£å†³æ–¹æ¡ˆçš„å¼ºå¤§æŠ€æœ¯ã€‚è¿™ç§æŠ€æœ¯åŒ…æ‹¬çº¿æ®µæ ‘DPä¼˜åŒ–ã€å‡¸åŒ…ä¼˜åŒ–ï¼ˆCHTï¼‰ã€åˆ†æ²»ä¼˜åŒ–å’Œæè¶…çº¿æ®µæ ‘ã€‚è¿™äº›æ–¹æ³•å¯ä»¥å°†æ—¶é—´å¤æ‚åº¦ä»O(nÂ²)æˆ–O(nÂ³)é™ä½åˆ°O(n log n)ç”šè‡³O(n)ï¼Œä½¿å¾—åœ¨ç«èµ›ç¼–ç¨‹æ—¶é—´é™åˆ¶å†…è§£å†³ä»¥å‰éš¾ä»¥å¤„ç†çš„é—®é¢˜æˆä¸ºå¯èƒ½ã€‚'
          : 'Data Structure Optimized Dynamic Programming is a powerful technique that transforms inefficient DP solutions into optimal ones using advanced data structures. This technique includes segment tree DP optimization, Convex Hull Trick (CHT), divide and conquer optimization, and Li Chao segment tree. These methods can reduce time complexity from O(nÂ²) or O(nÂ³) to O(n log n) or even O(n), making previously intractable problems solvable within competitive programming time limits.'
        }
      </p>
    </div>

    <!-- Segment Tree DP Optimization -->
    <section class="content-section">
      <h2>{lang === 'zh' ? 'çº¿æ®µæ ‘DPä¼˜åŒ–' : 'Segment Tree DP Optimization'}</h2>
      
      <div class="subsection">
        <h3>{lang === 'zh' ? 'æ ¸å¿ƒæ¦‚å¿µ' : 'Core Concept'}</h3>
        <p>
          {lang === 'zh'
            ? 'å½“DPè½¬ç§»æ¶‰åŠåŒºé—´æŸ¥è¯¢ï¼ˆæœ€å°å€¼ã€æœ€å¤§å€¼ã€æ±‚å’Œï¼‰æ—¶ï¼Œçº¿æ®µæ ‘å¯ä»¥å°†è¿™äº›æ“ä½œä»æ¯æ¬¡æŸ¥è¯¢O(n)ä¼˜åŒ–åˆ°O(log n)ã€‚å…¸å‹çš„æ¨¡å¼æ˜¯ï¼šdp[i] = optimal(dp[j] + cost(j, i))ï¼Œå…¶ä¸­jåœ¨æŸä¸ªåŒºé—´å†…å˜åŒ–ã€‚'
            : 'When DP transitions involve range queries (min, max, sum), segment trees can optimize these operations from O(n) to O(log n) per query. The typical pattern is: dp[i] = optimal(dp[j] + cost(j, i)) where j ranges over some interval.'
          }
        </p>
      </div>

      <CodeExample 
        client:load
        title={lang === 'zh' ? 'å¸¦æ‡’æ ‡è®°çš„çº¿æ®µæ ‘DP' : 'Segment Tree DP with Lazy Propagation'}
        code={`#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>
using namespace std;

class SegmentTreeDP {
private:
    vector<long long> tree, lazy;
    int n;
    
    void push(int node, int start, int end) {
        if (lazy[node] != 0) {
            tree[node] += lazy[node];
            if (start != end) {
                lazy[2 * node] += lazy[node];
                lazy[2 * node + 1] += lazy[node];
            }
            lazy[node] = 0;
        }
    }
    
    void updateRange(int node, int start, int end, int l, int r, long long val) {
        push(node, start, end);
        if (start > r || end < l) return;
        
        if (start >= l && end <= r) {
            lazy[node] += val;
            push(node, start, end);
            return;
        }
        
        int mid = (start + end) / 2;
        updateRange(2 * node, start, mid, l, r, val);
        updateRange(2 * node + 1, mid + 1, end, l, r, val);
        
        push(2 * node, start, mid);
        push(2 * node + 1, mid + 1, end);
        tree[node] = min(tree[2 * node], tree[2 * node + 1]);
    }
    
    long long queryRange(int node, int start, int end, int l, int r) {
        if (start > r || end < l) return LLONG_MAX;
        
        push(node, start, end);
        if (start >= l && end <= r) return tree[node];
        
        int mid = (start + end) / 2;
        return min(queryRange(2 * node, start, mid, l, r),
                  queryRange(2 * node + 1, mid + 1, end, l, r));
    }
    
public:
    SegmentTreeDP(int size) : n(size) {
        tree.assign(4 * n, LLONG_MAX);
        lazy.assign(4 * n, 0);
    }
    
    void update(int l, int r, long long val) {
        updateRange(1, 0, n - 1, l, r, val);
    }
    
    long long query(int l, int r) {
        if (l > r) return LLONG_MAX;
        return queryRange(1, 0, n - 1, l, r);
    }
    
    void pointUpdate(int idx, long long val) {
        updateRange(1, 0, n - 1, idx, idx, val);
    }
};

${lang === 'zh' ? '// ç¤ºä¾‹ï¼šå°†æ•°ç»„åˆ†æˆkæ®µçš„æœ€å°ä»£ä»·\n' : '// Example: Minimum cost to split array into k segments\n'}vector<long long> minCostSplit(vector<int>& arr, int k) {
    int n = arr.size();
    vector<long long> dp(n + 1, LLONG_MAX);
    dp[0] = 0;
    
    SegmentTreeDP segTree(n + 1);
    segTree.pointUpdate(0, 0);
    
    for (int i = 1; i <= n; i++) {
        ${lang === 'zh' ? '        // ä»æœ‰æ•ˆçš„å‰é¢ä½ç½®æŸ¥è¯¢æœ€å°å€¼\n' : '        // Query minimum from valid previous positions\n'}        long long minPrev = segTree.query(max(0, i - k), i - 1);
        if (minPrev != LLONG_MAX) {
            dp[i] = minPrev + arr[i - 1];
            segTree.pointUpdate(i, dp[i]);
        }
    }
    
    return dp;
}

int main() {
    vector<int> arr = {3, 1, 4, 1, 5, 9, 2, 6};
    int k = 3; ${lang === 'zh' ? '// æœ€å¤§æ®µé•¿åº¦\n' : '// Maximum segment length\n'}
    
    cout << "${lang === 'zh' ? 'æ•°ç»„: ' : 'Array: '}";
    for (int x : arr) cout << x << " ";
    cout << "\\n${lang === 'zh' ? 'æœ€å¤§æ®µé•¿åº¦: ' : 'Max segment length: '}" << k << endl;
    
    vector<long long> dp = minCostSplit(arr, k);
    cout << "${lang === 'zh' ? 'æœ€å°ä»£ä»·: ' : 'Minimum cost: '}" << dp.back() << endl;
    
    return 0;
}`}
        explanation={lang === 'zh' 
          ? 'å¸¦æ‡’æ ‡è®°çš„çº¿æ®µæ ‘æ”¯æŒé«˜æ•ˆçš„åŒºé—´æ›´æ–°å’ŒæŸ¥è¯¢ï¼Œå¯¹äºéœ€è¦åŒæ—¶æ›´æ–°å¤šä¸ªä½ç½®çš„å¤æ‚DPä¼˜åŒ–æ˜¯å¿…ä¸å¯å°‘çš„ã€‚'
          : 'Segment trees with lazy propagation support efficient range updates and queries, essential for complex DP optimizations where multiple positions need simultaneous updates.'
        }
        output={`${lang === 'zh' ? 'æ•°ç»„: ' : 'Array: '}3 1 4 1 5 9 2 6 
${lang === 'zh' ? 'æœ€å¤§æ®µé•¿åº¦: ' : 'Max segment length: '}3
${lang === 'zh' ? 'æœ€å°ä»£ä»·: ' : 'Minimum cost: '}31`}
      />
    </section>

    <!-- Convex Hull Trick -->
    <section class="content-section">
      <h2>{lang === 'zh' ? 'å‡¸åŒ…ä¼˜åŒ–ï¼ˆCHTï¼‰' : 'Convex Hull Trick (CHT)'}</h2>
      
      <div class="subsection">
        <h3>{lang === 'zh' ? 'ä½•æ—¶ä½¿ç”¨CHT' : 'When to Use CHT'}</h3>
        <p>
          {lang === 'zh'
            ? 'CHTä¼˜åŒ–å½¢å¦‚dp[i] = min(dp[j] + b[j] * a[i] + c[i])çš„DPè½¬ç§»ï¼Œå…¶ä¸­æ–œç‡b[j]å•è°ƒä¸”æŸ¥è¯¢ç‚¹a[i]å•è°ƒã€‚è¿™å°†å¤æ‚åº¦ä»O(nÂ²)é™ä½åˆ°O(n)ã€‚'
            : 'CHT optimizes DP transitions of the form: dp[i] = min(dp[j] + b[j] * a[i] + c[i]) where slopes b[j] are monotonic and query points a[i] are monotonic. This reduces complexity from O(nÂ²) to O(n).'
          }
        </p>
      </div>

      <CodeExample 
        client:load
        title={lang === 'zh' ? 'åŒç«¯é˜Ÿåˆ—ä¼˜åŒ–çš„å‡¸åŒ…æŠ€å·§' : 'Convex Hull Trick with Deque Optimization'}
        code={`#include <iostream>
#include <vector>
#include <deque>
#include <climits>
using namespace std;

struct Line {
    long long slope, intercept;
    int id;
    
    Line(long long slope, long long intercept, int id = -1) 
        : slope(slope), intercept(intercept), id(id) {}
    
    long long eval(long long x) const {
        return slope * x + intercept;
    }
    
    ${lang === 'zh' ? '    // æ£€æŸ¥åœ¨ç»™å®šä¸¤æ¡å…¶ä»–ç›´çº¿çš„æƒ…å†µä¸‹ï¼Œè¿™æ¡ç›´çº¿æ˜¯å¦å†—ä½™\n' : '    // Check if this line is redundant given two other lines\n'}    bool isBad(const Line& l1, const Line& l2) const {
        ${lang === 'zh' ? '        // å‰ç§¯æ¯”è¾ƒä»¥é¿å…æµ®ç‚¹æ•°\n' : '        // Cross product comparison to avoid floating point\n'}        return (intercept - l1.intercept) * (l1.slope - l2.slope) 
               <= (l2.intercept - l1.intercept) * (l1.slope - slope);
    }
};

class ConvexHullTrick {
private:
    deque<Line> lines;
    
public:
    void addLine(long long slope, long long intercept, int id = -1) {
        Line newLine(slope, intercept, id);
        
        ${lang === 'zh' ? '        // ç§»é™¤å˜å¾—å†—ä½™çš„ç›´çº¿\n' : '        // Remove lines that become redundant\n'}        while (lines.size() >= 2 && 
               newLine.isBad(lines[lines.size()-2], lines[lines.size()-1])) {
            lines.pop_back();
        }
        
        lines.push_back(newLine);
    }
    
    pair<long long, int> query(long long x) {
        if (lines.empty()) return {LLONG_MAX, -1};
        
        ${lang === 'zh' ? '        // ç§»é™¤ä¸å†æœ€ä¼˜çš„ç›´çº¿\n' : '        // Remove lines that are no longer optimal\n'}        while (lines.size() >= 2 && 
               lines[0].eval(x) >= lines[1].eval(x)) {
            lines.pop_front();
        }
        
        return {lines[0].eval(x), lines[0].id};
    }
    
    long long queryValue(long long x) {
        return query(x).first;
    }
};

${lang === 'zh' ? '// ç¤ºä¾‹ï¼šå·¥å‚ç”Ÿäº§ä¼˜åŒ–\n// dp[i] = min(dp[j] + setup_cost[j] * demand[i] + production_cost[i])\n' : '// Example: Factory production optimization\n// dp[i] = min(dp[j] + setup_cost[j] * demand[i] + production_cost[i])\n'}vector<long long> optimizeProduction(vector<long long>& setup_cost, 
                                    vector<long long>& demand, 
                                    vector<long long>& production_cost) {
    int n = setup_cost.size();
    vector<long long> dp(n + 1, LLONG_MAX);
    dp[0] = 0;
    
    ConvexHullTrick cht;
    cht.addLine(0, 0, 0); ${lang === 'zh' ? '// åˆå§‹çŠ¶æ€\n' : '// Initial state\n'}
    
    for (int i = 1; i <= n; i++) {
        auto [cost, from] = cht.query(demand[i - 1]);
        dp[i] = cost + production_cost[i - 1];
        
        ${lang === 'zh' ? '        // ä¸ºæœªæ¥è½¬ç§»æ·»åŠ æ–°ç›´çº¿\n' : '        // Add new line for future transitions\n'}        if (i < n) {
            cht.addLine(-setup_cost[i - 1], dp[i], i);
        }
    }
    
    return dp;
}

int main() {
    vector<long long> setup_cost = {2, 3, 1, 4, 2};
    vector<long long> demand = {1, 2, 3, 2, 1};
    vector<long long> production_cost = {5, 3, 4, 2, 6};
    
    cout << "${lang === 'zh' ? 'è®¾ç½®æˆæœ¬: ' : 'Setup costs: '}";
    for (long long x : setup_cost) cout << x << " ";
    cout << "\\n${lang === 'zh' ? 'éœ€æ±‚: ' : 'Demand: '}";
    for (long long x : demand) cout << x << " ";
    cout << "\\n${lang === 'zh' ? 'ç”Ÿäº§æˆæœ¬: ' : 'Production costs: '}";
    for (long long x : production_cost) cout << x << " ";
    cout << endl;
    
    vector<long long> dp = optimizeProduction(setup_cost, demand, production_cost);
    cout << "${lang === 'zh' ? 'æœ€å°æ€»æˆæœ¬: ' : 'Minimum total cost: '}" << dp.back() << endl;
    
    return 0;
}`}
        explanation={lang === 'zh' 
          ? 'CHTç»´æŠ¤çº¿æ€§å‡½æ•°çš„å‡¸åŒ…ï¼Œå½“æŸ¥è¯¢å’Œæ–œç‡éƒ½æ˜¯å•è°ƒçš„æ—¶å€™ï¼Œå…è®¸åœ¨æ‘Šé”€O(1)æ—¶é—´å†…è¿›è¡Œæœ€ä¼˜DPè½¬ç§»ã€‚'
          : 'CHT maintains a convex hull of linear functions, allowing optimal DP transitions in O(1) amortized time when queries and slopes are monotonic.'
        }
        output={`${lang === 'zh' ? 'è®¾ç½®æˆæœ¬: ' : 'Setup costs: '}2 3 1 4 2 
${lang === 'zh' ? 'éœ€æ±‚: ' : 'Demand: '}1 2 3 2 1 
${lang === 'zh' ? 'ç”Ÿäº§æˆæœ¬: ' : 'Production costs: '}5 3 4 2 6 
${lang === 'zh' ? 'æœ€å°æ€»æˆæœ¬: ' : 'Minimum total cost: '}20`}
      />
    </section>

    <!-- Li Chao Segment Tree -->
    <section class="content-section">
      <h2>{lang === 'zh' ? 'æè¶…çº¿æ®µæ ‘' : 'Li Chao Segment Tree'}</h2>
      
      <div class="subsection">
        <h3>{lang === 'zh' ? 'é«˜çº§ç›´çº¿ç®¡ç†' : 'Advanced Line Management'}</h3>
        <p>
          {lang === 'zh'
            ? 'æè¶…çº¿æ®µæ ‘åœ¨CHTæ¡ä»¶ä¸æ»¡è¶³æ—¶å¤„ç†åŠ¨æ€ç›´çº¿æ’å…¥å’Œç‚¹æŸ¥è¯¢ã€‚å®ƒä¸ºæ¯ä¸ªæ®µç»´æŠ¤æœ€ä¼˜ç›´çº¿ï¼Œæ”¯æŒä»»æ„ç›´çº¿æ’å…¥é¡ºåºã€‚'
            : 'Li Chao segment tree handles dynamic line insertion and point queries when CHT conditions aren\'t met. It maintains the optimal line for each segment, supporting arbitrary line insertion order.'
          }
        </p>
      </div>

      <CodeExample 
        client:load
        title={lang === 'zh' ? 'æè¶…çº¿æ®µæ ‘å®ç°' : 'Li Chao Segment Tree Implementation'}
        code={`#include <iostream>
#include <vector>
#include <climits>
using namespace std;

struct Line {
    long long a, b; ${lang === 'zh' ? '// y = ax + b\n' : '// y = ax + b\n'}    
    Line(long long a = 0, long long b = LLONG_MAX) : a(a), b(b) {}
    
    long long eval(long long x) const {
        if (b == LLONG_MAX) return LLONG_MAX;
        return a * x + b;
    }
};

class LiChaoTree {
private:
    vector<Line> tree;
    int n;
    
    void update(int node, int start, int end, Line line) {
        if (start == end) {
            if (line.eval(start) < tree[node].eval(start)) {
                tree[node] = line;
            }
            return;
        }
        
        int mid = (start + end) / 2;
        bool left_better = line.eval(start) < tree[node].eval(start);
        bool mid_better = line.eval(mid) < tree[node].eval(mid);
        
        if (mid_better) {
            swap(tree[node], line);
        }
        
        if (left_better != mid_better) {
            update(2 * node, start, mid, line);
        } else {
            update(2 * node + 1, mid + 1, end, line);
        }
    }
    
    long long query(int node, int start, int end, int pos) {
        if (start == end) {
            return tree[node].eval(pos);
        }
        
        int mid = (start + end) / 2;
        long long result = tree[node].eval(pos);
        
        if (pos <= mid) {
            result = min(result, query(2 * node, start, mid, pos));
        } else {
            result = min(result, query(2 * node + 1, mid + 1, end, pos));
        }
        
        return result;
    }
    
public:
    LiChaoTree(int size) : n(size) {
        tree.assign(4 * n, Line());
    }
    
    void addLine(long long a, long long b) {
        update(1, 0, n - 1, Line(a, b));
    }
    
    long long queryMin(int x) {
        return query(1, 0, n - 1, x);
    }
};

${lang === 'zh' ? '// ç¤ºä¾‹ï¼šä»»æ„ç›´çº¿æ’å…¥çš„åŠ¨æ€è§„åˆ’\n' : '// Example: Dynamic programming with arbitrary line insertion\n'}vector<long long> solveWithLiChao(vector<int>& costs, vector<int>& multipliers) {
    int n = costs.size();
    vector<long long> dp(n + 1, LLONG_MAX);
    dp[0] = 0;
    
    LiChaoTree lct(n + 1);
    lct.addLine(0, 0); ${lang === 'zh' ? '// åˆå§‹ç›´çº¿\n' : '// Initial line\n'}
    
    for (int i = 1; i <= n; i++) {
        dp[i] = lct.queryMin(multipliers[i - 1]) + costs[i - 1];
        
        ${lang === 'zh' ? '        // ä¸ºæœªæ¥çŠ¶æ€æ·»åŠ æ–°ç›´çº¿\n' : '        // Add new line for future states\n'}        lct.addLine(-i, dp[i]);
    }
    
    return dp;
}

int main() {
    vector<int> costs = {3, 1, 4, 1, 5};
    vector<int> multipliers = {2, 1, 3, 2, 1};
    
    cout << "${lang === 'zh' ? 'æˆæœ¬: ' : 'Costs: '}";
    for (int x : costs) cout << x << " ";
    cout << "\\n${lang === 'zh' ? 'ä¹˜æ•°: ' : 'Multipliers: '}";
    for (int x : multipliers) cout << x << " ";
    cout << endl;
    
    vector<long long> dp = solveWithLiChao(costs, multipliers);
    cout << "${lang === 'zh' ? 'æœ€ä¼˜ç»“æœ: ' : 'Optimal result: '}" << dp.back() << endl;
    
    return 0;
}`}
        explanation={lang === 'zh' 
          ? 'æè¶…çº¿æ®µæ ‘ä¸ºæ¯ä¸ªæ®µç»´æŠ¤æœ€ä¼˜ç›´çº¿ï¼Œå¤„ç†CHTæ— æ³•ç®¡ç†çš„ä»»æ„ç›´çº¿æ’å…¥æ¨¡å¼ã€‚'
          : 'Li Chao segment tree maintains the optimal line for each segment, handling arbitrary line insertion patterns that CHT cannot manage.'
        }
        output={`${lang === 'zh' ? 'æˆæœ¬: ' : 'Costs: '}3 1 4 1 5 
${lang === 'zh' ? 'ä¹˜æ•°: ' : 'Multipliers: '}2 1 3 2 1 
${lang === 'zh' ? 'æœ€ä¼˜ç»“æœ: ' : 'Optimal result: '}14`}
      />
    </section>

    <!-- Divide and Conquer DP -->
    <section class="content-section">
      <h2>{lang === 'zh' ? 'åˆ†æ²»DP' : 'Divide and Conquer DP'}</h2>
      
      <div class="subsection">
        <h3>{lang === 'zh' ? 'å››è¾¹å½¢ä¸ç­‰å¼ä¼˜åŒ–' : 'Quadrangle Inequality Optimization'}</h3>
        <p>
          {lang === 'zh'
            ? 'å½“DPé€’æ¨æ»¡è¶³å››è¾¹å½¢ä¸ç­‰å¼ï¼ˆMongeæ€§è´¨ï¼‰æ—¶ï¼Œåˆ†æ²»ä¼˜åŒ–å°†å¤æ‚åº¦ä»O(knÂ²)é™ä½åˆ°O(kn log n)ã€‚å…³é”®æ´å¯Ÿæ˜¯æœ€ä¼˜åˆ†å‰²ç‚¹æ˜¯å•è°ƒçš„ã€‚'
            : 'When the DP recurrence satisfies the quadrangle inequality (Monge property), divide and conquer optimization reduces complexity from O(knÂ²) to O(kn log n). The key insight is that optimal split points are monotonic.'
          }
        </p>
      </div>

      <CodeExample 
        client:load
        title={lang === 'zh' ? 'åˆ†æ²»DPä¼˜åŒ–' : 'Divide and Conquer DP Optimization'}
        code={`#include <iostream>
#include <vector>
#include <climits>
using namespace std;

class DivideConquerDP {
private:
    vector<vector<long long>> dp;
    vector<long long> cost;
    int n, k;
    
    ${lang === 'zh' ? '    // ä»£ä»·å‡½æ•° - å¿…é¡»æ»¡è¶³å››è¾¹å½¢ä¸ç­‰å¼\n' : '    // Cost function - must satisfy quadrangle inequality\n'}    long long C(int i, int j) {
        if (i > j) return LLONG_MAX;
        return (cost[j] - cost[i]) * (cost[j] - cost[i]);
    }
    
    void compute(int level, int left, int right, int opt_left, int opt_right) {
        if (left > right) return;
        
        int mid = (left + right) / 2;
        int best_k = -1;
        long long best_cost = LLONG_MAX;
        
        ${lang === 'zh' ? '        // ä¸ºä½ç½®midæ‰¾åˆ°æœ€ä¼˜åˆ†å‰²ç‚¹\n' : '        // Find optimal split point for position mid\n'}        for (int split = opt_left; split <= min(mid - 1, opt_right); split++) {
            long long current_cost = dp[level - 1][split] + C(split + 1, mid);
            if (current_cost < best_cost) {
                best_cost = current_cost;
                best_k = split;
            }
        }
        
        dp[level][mid] = best_cost;
        
        ${lang === 'zh' ? '        // é€’å½’è§£å†³å·¦å³ä¸¤éƒ¨åˆ†\n' : '        // Recursively solve left and right parts\n'}        compute(level, left, mid - 1, opt_left, best_k);
        compute(level, mid + 1, right, best_k, opt_right);
    }
    
public:
    vector<long long> solve(vector<long long>& arr, int groups) {
        n = arr.size();
        k = groups;
        cost = arr;
        
        ${lang === 'zh' ? '        // è®¡ç®—å‰ç¼€å’Œç”¨äºä»£ä»·å‡½æ•°\n' : '        // Compute prefix sums for cost function\n'}        for (int i = 1; i < n; i++) {
            cost[i] += cost[i - 1];
        }
        
        dp.assign(k + 1, vector<long long>(n, LLONG_MAX));
        
        ${lang === 'zh' ? '        // åŸºç¡€æƒ…å†µï¼šä¸€ç»„\n' : '        // Base case: one group\n'}        for (int i = 0; i < n; i++) {
            dp[1][i] = C(0, i);
        }
        
        ${lang === 'zh' ? '        // ä½¿ç”¨åˆ†æ²»å¡«å……DPè¡¨\n' : '        // Fill DP table using divide and conquer\n'}        for (int level = 2; level <= k; level++) {
            compute(level, level - 1, n - 1, level - 2, n - 2);
        }
        
        return dp[k];
    }
};

int main() {
    vector<long long> arr = {1, 2, 3, 4, 5, 6, 7, 8};
    int k = 3; ${lang === 'zh' ? '// ç»„æ•°\n' : '// Number of groups\n'}
    
    cout << "${lang === 'zh' ? 'æ•°ç»„: ' : 'Array: '}";
    for (long long x : arr) cout << x << " ";
    cout << "\\n${lang === 'zh' ? 'ç»„æ•°: ' : 'Number of groups: '}" << k << endl;
    
    DivideConquerDP solver;
    vector<long long> result = solver.solve(arr, k);
    
    cout << "${lang === 'zh' ? 'æœ€å°ä»£ä»·: ' : 'Minimum cost: '}" << result[arr.size() - 1] << endl;
    
    return 0;
}`}
        explanation={lang === 'zh' 
          ? 'åˆ†æ²»DPåˆ©ç”¨ä»£ä»·å‡½æ•°æ»¡è¶³å››è¾¹å½¢ä¸ç­‰å¼æ—¶æœ€ä¼˜åˆ†å‰²ç‚¹çš„å•è°ƒæ€§ï¼Œæ˜¾è‘—é™ä½æ—¶é—´å¤æ‚åº¦ã€‚'
          : 'Divide and conquer DP leverages the monotonicity of optimal split points when the cost function satisfies quadrangle inequality, dramatically reducing time complexity.'
        }
        output={`${lang === 'zh' ? 'æ•°ç»„: ' : 'Array: '}1 2 3 4 5 6 7 8 
${lang === 'zh' ? 'ç»„æ•°: ' : 'Number of groups: '}3
${lang === 'zh' ? 'æœ€å°ä»£ä»·: ' : 'Minimum cost: '}16`}
      />
    </section>

    <!-- Tips Section -->
    <section class="tips-section">
      <h2>{lang === 'zh' ? 'ä¼˜åŒ–ç­–ç•¥æŒ‡å—' : 'Optimization Strategy Guide'}</h2>
      
      <div class="tips-grid">
        <div class="tip-card">
          <h3>ğŸ¯ {lang === 'zh' ? 'ä½•æ—¶ä½¿ç”¨æ¯ç§æŠ€æœ¯' : 'When to Use Each Technique'}</h3>
          <ul>
            <li><strong>{lang === 'zh' ? 'çº¿æ®µæ ‘ï¼š' : 'Segment Tree:'}</strong> {lang === 'zh' ? 'DPè½¬ç§»ä¸­çš„åŒºé—´æŸ¥è¯¢' : 'Range queries in DP transitions'}</li>
            <li><strong>CHT:</strong> {lang === 'zh' ? 'æ–œç‡å•è°ƒçš„çº¿æ€§å‡½æ•°' : 'Linear functions with monotonic slopes'}</li>
            <li><strong>{lang === 'zh' ? 'æè¶…ï¼š' : 'Li Chao:'}</strong> {lang === 'zh' ? 'ä»»æ„ç›´çº¿æ’å…¥æ¨¡å¼' : 'Arbitrary line insertion patterns'}</li>
            <li><strong>{lang === 'zh' ? 'åˆ†æ²»ï¼š' : 'Divide & Conquer:'}</strong> {lang === 'zh' ? 'æ»¡è¶³å››è¾¹å½¢ä¸ç­‰å¼' : 'Quadrangle inequality satisfied'}</li>
          </ul>
        </div>
        
        <div class="tip-card">
          <h3>âš¡ {lang === 'zh' ? 'æ€§èƒ½è€ƒè™‘' : 'Performance Considerations'}</h3>
          <ul>
            <li><strong>{lang === 'zh' ? 'å†…å­˜ï¼š' : 'Memory:'}</strong> {lang === 'zh' ? 'çº¿æ®µæ ‘éœ€è¦4nç©ºé—´' : 'Segment trees need 4n space'}</li>
            <li><strong>{lang === 'zh' ? 'å¸¸æ•°ï¼š' : 'Constants:'}</strong> {lang === 'zh' ? 'CHTæ¯”æè¶…æœ‰æ›´å¥½çš„å¸¸æ•°' : 'CHT has better constants than Li Chao'}</li>
            <li><strong>{lang === 'zh' ? 'ç²¾åº¦ï¼š' : 'Precision:'}</strong> {lang === 'zh' ? 'å°½å¯èƒ½ä½¿ç”¨æ•´æ•°è¿ç®—' : 'Use integer arithmetic when possible'}</li>
            <li><strong>{lang === 'zh' ? 'ç¼“å­˜ï¼š' : 'Cache:'}</strong> {lang === 'zh' ? 'é¡ºåºè®¿é—®æ¨¡å¼æ›´å¿«' : 'Sequential access patterns are faster'}</li>
          </ul>
        </div>
        
        <div class="tip-card">
          <h3>ğŸ”§ {lang === 'zh' ? 'å®ç°æŠ€å·§' : 'Implementation Tips'}</h3>
          <ul>
            <li><strong>{lang === 'zh' ? 'æº¢å‡ºï¼š' : 'Overflow:'}</strong> {lang === 'zh' ? 'ä¸­é—´è®¡ç®—ä½¿ç”¨long long' : 'Use long long for intermediate calculations'}</li>
            <li><strong>{lang === 'zh' ? 'è¾¹ç•Œæƒ…å†µï¼š' : 'Edge Cases:'}</strong> {lang === 'zh' ? 'å¤„ç†ç©ºåŒºé—´å’Œå•å…ƒç´ ' : 'Handle empty ranges and single elements'}</li>
            <li><strong>{lang === 'zh' ? 'è°ƒè¯•ï¼š' : 'Debugging:'}</strong> {lang === 'zh' ? 'éªŒè¯å•è°ƒæ€§æ¡ä»¶' : 'Verify monotonicity conditions'}</li>
            <li><strong>{lang === 'zh' ? 'æµ‹è¯•ï¼š' : 'Testing:'}</strong> {lang === 'zh' ? 'å°è¾“å…¥ä¸æš´åŠ›æ¯”è¾ƒ' : 'Compare with brute force on small inputs'}</li>
          </ul>
        </div>
        
        <div class="tip-card">
          <h3>ğŸ“Š {lang === 'zh' ? 'å¤æ‚åº¦åˆ†æ' : 'Complexity Analysis'}</h3>
          <ul>
            <li><strong>{lang === 'zh' ? 'çº¿æ®µæ ‘DPï¼š' : 'Segment Tree DP:'}</strong> {lang === 'zh' ? 'æ¯æ¬¡è½¬ç§»O(n log n)' : 'O(n log n) per transition'}</li>
            <li><strong>CHT:</strong> {lang === 'zh' ? 'å•è°ƒæŸ¥è¯¢æ€»è®¡O(n)' : 'O(n) total with monotonic queries'}</li>
            <li><strong>{lang === 'zh' ? 'æè¶…ï¼š' : 'Li Chao:'}</strong> {lang === 'zh' ? 'næ¡ç›´çº¿å’ŒæŸ¥è¯¢O(n log n)' : 'O(n log n) for n lines and queries'}</li>
            <li><strong>{lang === 'zh' ? 'åˆ†æ²»DPï¼š' : 'D&C DP:'}</strong> {lang === 'zh' ? 'kç»„O(kn log n)' : 'O(kn log n) for k groups'}</li>
          </ul>
        </div>
      </div>
    </section>

    <!-- Navigation -->
    <div class="navigation">
      <a href={`/${lang}/5-advanced/binary-trie`} class="nav-button prev">
        â† {lang === 'zh' ? 'äºŒè¿›åˆ¶å­—å…¸æ ‘' : 'Binary Trie'}
      </a>
      <a href={`/${lang}/5-advanced`} class="nav-button index">
        ğŸ“š {lang === 'zh' ? 'é«˜çº§ç®—æ³•ç›®å½•' : 'Advanced Algorithms Index'}
      </a>
      <a href={`/${lang}/5-advanced/sweep-line`} class="nav-button next">
        {lang === 'zh' ? 'æ‰«æçº¿ç®—æ³•' : 'Sweep Line Algorithm'} â†’
      </a>
    </div>
  </div>
</Layout>

<style>
  .container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 0 1rem;
  }

  .breadcrumbs ul {
    list-style: none;
    padding: 0;
    margin: 0;
  }

  .breadcrumbs {
    padding: 1rem 0;
    border-bottom: 1px solid #e5e7eb;
    margin-bottom: 2rem;
  }

  .breadcrumbs a {
    color: #4f46e5;
    text-decoration: none;
    transition: color 0.2s;
  }

  .breadcrumbs a:hover {
    color: #3730a3;
    text-decoration: underline;
  }

  .main-title {
    font-size: 3rem;
    font-weight: 800;
    margin-bottom: 2rem;
    background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 50%, #ec4899 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    line-height: 1.2;
    text-align: center;
  }

  .overview-section {
    background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
    border: 1px solid #e2e8f0;
    border-radius: 16px;
    padding: 2.5rem;
    margin: 2rem 0 3rem 0;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
    position: relative;
    overflow: hidden;
  }

  .overview-section::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 4px;
    background: linear-gradient(90deg, #4f46e5, #7c3aed, #ec4899);
  }

  .overview-section h2 {
    color: #1e293b;
    font-size: 1.5rem;
    font-weight: 700;
    margin-bottom: 1rem;
    border: none;
    padding: 0;
  }

  .overview-section p {
    margin: 0;
    font-size: 1.1rem;
    line-height: 1.8;
    color: #374151;
  }

  .content-section {
    margin: 4rem 0;
    padding: 2rem 0;
    border-bottom: 1px solid #e5e7eb;
  }

  .content-section:last-of-type {
    border-bottom: none;
  }

  .content-section h2 {
    font-size: 2.25rem;
    font-weight: 700;
    margin-bottom: 1.5rem;
    color: #1e293b;
    position: relative;
    padding-bottom: 0.5rem;
  }

  .content-section h2::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    width: 60px;
    height: 3px;
    background: linear-gradient(90deg, #4f46e5, #7c3aed);
    border-radius: 2px;
  }

  .subsection {
    margin: 2rem 0;
    padding: 1.5rem;
    background: #f9fafb;
    border-radius: 12px;
    border-left: 4px solid #4f46e5;
  }

  .subsection h3 {
    font-size: 1.25rem;
    font-weight: 600;
    color: #1e293b;
    margin-bottom: 1rem;
  }

  .subsection p {
    margin: 0;
    color: #4b5563;
    line-height: 1.7;
  }

  .tips-section {
    margin: 4rem 0;
    padding: 2rem 0;
  }

  .tips-section h2 {
    font-size: 2.25rem;
    font-weight: 700;
    margin-bottom: 2rem;
    color: #1e293b;
    text-align: center;
  }

  .tips-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 1.5rem;
    margin-top: 2rem;
  }

  .tip-card {
    background: white;
    border-radius: 12px;
    padding: 1.5rem;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
    border: 1px solid #e5e7eb;
    transition: transform 0.2s, box-shadow 0.2s;
  }

  .tip-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 10px 25px -3px rgba(0, 0, 0, 0.1);
  }

  .tip-card h3 {
    font-size: 1.1rem;
    font-weight: 600;
    margin-bottom: 1rem;
    color: #1e293b;
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .tip-card ul {
    list-style: none;
    padding: 0;
    margin: 0;
  }

  .tip-card li {
    padding: 0.5rem 0;
    color: #4b5563;
    border-bottom: 1px solid #f3f4f6;
    line-height: 1.5;
  }

  .tip-card li:last-child {
    border-bottom: none;
  }

  .tip-card strong {
    color: #1e293b;
    font-weight: 600;
  }

  .navigation {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin: 4rem 0 2rem 0;
    padding: 2rem 0;
    border-top: 2px solid #e5e7eb;
    gap: 1rem;
  }

  .nav-button {
    display: inline-flex;
    align-items: center;
    padding: 0.875rem 1.75rem;
    background: linear-gradient(135deg, #4f46e5, #7c3aed);
    color: white;
    text-decoration: none;
    border-radius: 10px;
    font-weight: 600;
    font-size: 0.95rem;
    transition: all 0.3s ease;
    box-shadow: 0 4px 14px 0 rgba(79, 70, 229, 0.39);
    border: none;
  }

  .nav-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px 0 rgba(79, 70, 229, 0.5);
  }

  .nav-button.index {
    background: linear-gradient(135deg, #059669, #0d9488);
    box-shadow: 0 4px 14px 0 rgba(5, 150, 105, 0.39);
  }

  .nav-button.index:hover {
    box-shadow: 0 8px 25px 0 rgba(5, 150, 105, 0.5);
  }

  @media (max-width: 768px) {
    .container {
      padding: 0 0.5rem;
    }

    .main-title {
      font-size: 2.5rem;
    }

    .overview-section {
      padding: 1.5rem;
      margin: 1.5rem 0 2rem 0;
    }

    .content-section h2 {
      font-size: 1.875rem;
    }

    .tips-grid {
      grid-template-columns: 1fr;
    }

    .navigation {
      flex-direction: column;
      gap: 1rem;
    }

    .nav-button {
      width: 100%;
      justify-content: center;
    }
  }
</style> 